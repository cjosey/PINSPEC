/*
 * Tally.h
 *
 *  Created on: Mar 13, 2012
 *      Author: William Boyd
 *				MIT, Course 22
 *              wboyd@mit.edu
 */

#ifndef TALLY_H_
#define TALLY_H_

#ifdef __cplusplus
#include <limits>
#include <math.h>
#endif
#include "log.h"
#include "arraycreator.h"


/* Tally spacing types */
typedef enum binSpacingTypes {
	EQUAL,
	LOGARITHMIC,
	OTHER
} binSpacingType;


/* The domain in which this tally resides */
typedef enum tallyDomainTypes {
	MATERIAL,
	ISOTOPE,
	REGION,
    GEOMETRY
} tallyDomainType;


/* The type of precision trigger for a Tally object - represents
 * what kind of precision we should track to determine when to end
 * the simulation */
typedef enum triggerTypes {
    VARIANCE,
    STANDARD_DEVIATION,
    RELATIVE_ERROR,
    NONE
} triggerType;


/* Type of tallies */
typedef enum tallyTypes {
	FLUX,
	COLLISION_RATE,
	MICRO_ELASTIC_RATE,
	MACRO_ELASTIC_RATE,
	MICRO_ABSORPTION_RATE,
	MACRO_ABSORPTION_RATE,
	MICRO_CAPTURE_RATE,
	MACRO_CAPTURE_RATE,
	MICRO_FISSION_RATE,
	MACRO_FISSION_RATE,
	// transport or diffusion? 
	MICRO_TRANSPORT_RATE,
	MACRO_TRANSPORT_RATE,
	DIFFUSION_RATE,
	LEAKAGE_RATE
} tallyType;


/**
 * This class represents a set of tallies. A set of values
 * define the edges between bins for each tally. This class 
 * holds the edges, the centers between bins. It also allows 
 * for tallies to be made within each bin.
 */
#ifdef __cplusplus
class Tally{

private:
	char* _tally_name;
	int _num_bins;
	double* _edges;
	double* _centers;
	double** _tallies;
	double _bin_delta;
	binSpacingType _bin_spacing;
	tallyDomainType _tally_domain;
	tallyType _tally_type;
    triggerType _trigger_type;
    float _trigger_precision;

	int _num_batches;
	double* _batch_mu;
	double* _batch_variance;
	double* _batch_std_dev;
	double* _batch_rel_err;
	bool _computed_statistics;

    double getMaxVariance();
    double getMaxStdDev();
    double getMaxRelErr();

public:
	Tally(char* tally_name, tallyDomainType tally_domain, tallyType tally_type);
	virtual ~Tally();
	char* getTallyName();
	int getNumBins();
	double* getBinEdges();
	double* getBinCenters();
	double getBinDelta();
	double getBinDelta(double sample);
	binSpacingType getBinSpacingType();
	tallyDomainType getTallyDomainType();
	tallyType getTallyType();
	double** getTallies();
	double getTally(int bin_index, int batch_num);
	double getMaxTally();
	double getMinTally();
	int getBinIndex(double sample);

    /* IMPORTANT: The following five class method prototypes must not be changed
     * without changing Geometry.i to allow for the data arrays to be transformed
     * into numpy arrays */
    void retrieveTallyEdges(double* data, int num_bins);
    void retrieveTallyCenters(double* data, int num_bins);
    void retrieveTallyMu(double* data, int num_bins);
    void retrieveTallyVariance(double* data, int num_bins);
    void retrieveTallyStdDev(double* data, int num_bins);
    void retrieveTallyRelErr(double* data, int num_bins);

	int getNumBatches();
	double* getBatchMu();
	double* getBatchVariance();
	double* getBatchStdDev();
	double* getBatchRelativeError();

    void setBinSpacingType(binSpacingType type);
	void setBinEdges(double* edges, int num_edges);
    void setPrecisionTrigger(triggerType trigger_type, float precision);

	void generateBinEdges(double start, double end, int num_bins, 
											binSpacingType type);
	void setNumBatches(int num_batches);
    void incrementNumBatches(int num_batches);
    bool isPrecisionTriggered();
	Tally* clone();

	void generateBinCenters();

	void tally(double* samples, int num_samples, int batch_num);
	void tally(double sample, int batch_num);
	void weightedTally(double* samples, double* sample_weights, 
			   int num_samples, int batch_num);
	void weightedTally(double sample, double weight, int batch_num);
	void normalizeTallies();
	void normalizeTallies(double scale_factor);
	void computeBatchStatistics();
	void computeScaledBatchStatistics(double scale_factor);
	void outputBatchStatistics(const char* filename);
};


/**
 * Finds the bin index for a sample in a set of bins. If the samples
 * is outside the bounds of all bins, it returns infinity
 * @param sample the sample value of interest
 * @return the bin index for the sample
 */
inline int Tally::getBinIndex(double sample) {

	if (_num_bins == 0)
		 log_printf(ERROR, "Cannot return a bin index for Tally %s since "
				 "the bins have not yet been created", _tally_name);

	/* Set index to infinity to begin with */
	int index = std::numeric_limits<int>::infinity();

	/* if the sample is equal to the last bin edge, return the last bin */
	if (sample == _edges[_num_bins])
		return _num_bins-1;

	/* Equally spaced bins */
	if (_bin_spacing == EQUAL)
		index = int((sample - _edges[0]) / _bin_delta);

	/* Logarithmically spaced bins */
	else if (_bin_spacing == LOGARITHMIC)
		index = int((log10(sample) - log10(_edges[0])) / _bin_delta);

	/* If the bin_type == OTHER then the bin edges were not generated by
	 * generateEqualBinEdges, so use a brute force search to find the bin */
	else {

		/* Loop over all bin edges to find the correct bin index */
		for (int i=0; i <= _num_bins; i++) {
			if (sample >= _edges[i] && sample < _edges[i+1]) {
				index = i;
				break;
			}
		}
	}

	/* If this sample was not contained within a bin set index to infinity*/
	if (index > _num_bins)
		index = std::numeric_limits<int>::infinity();

	return index;
}

#endif

#endif /* BINNER_H_ */
