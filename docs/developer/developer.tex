\documentclass[titlepage]{article}
\usepackage{school-style-packages}
\usepackage[cc]{titlepic}
\newcommand{\hi}[1]{\textbf{\textcolor{blue}{#1}}}

% For generating landscape orientated image, use Figure
\newenvironment{Figure}[1][!t]
  {\begin{landscape}\thispagestyle{empty}\begin{figure}}
  {\end{figure}\null\vfill\centerline{\raisebox{-2cm}{\thepage}}\end{landscape}}

\begin{document}
\title{Developer's Guide for PINSPEC}
\titlepic{\includegraphics[width=\textwidth]{images/pinspec.png}}
\maketitle

\section{Introduction}
\subsection{Intro to Developer's Guide}
This document is meant to provide information in addition to the user guide hosted on \href{https://github.com/mit-crpg/PINSPEC/wiki}{GitHub's wiki pages}. A number of instructions on how to install the required packages and PINSPEC, how to set up the python input files, and how to run the code can be found on the above link. Some of these info may be repeated in this document, but as a general rule of thumb users should refer to the wiki page for instructions related to using PINSPEC, and this document is reserved for info on developing PINSPEC. 

While the rest of this section would provide a high-level introduction of how PINSPEC source codes are constructed, the next couple of sections in this document would be devoted to:
\begin{itemize}
\item Review some essential instructions for installing PINSPEC and running PINSPEC, see Section~\ref{install}. 
\item Discuss how to manipulate the python codes, see Section~\ref{python}.
\item Discuss how to manipulate the C++ codes, see Section~\ref{C++}. 
\end{itemize}
Keep in mind that the above info is in addition to the commenting in the source codes and Doxygen-generated files as hosted here: \href{http://mit-crpg.github.io/PINSPEC/index.html}{Doxygen generated documents}. 


\clearpage
\subsection{Python to SWIG to C++}
Fig.~\ref{high-level} illustrates the three major components of PINSPEC: the python codes, the SWIG interface, and the C++ source codes. 

Simplified Wrapper and Interface Generator (SWIG) is open source software used in PINSPEC to wrap C++ functions for use with python. More generally, SWIG can be used to connect C/C++ with scripting languages such as Lua, Perl, PHP, Python, R, Ruby, Tcl and even non-scripting languages like C\#, Java, JavaScript, Go, Modula-3, Ocaml, Octave, and Scheme\footnote{Reference: \href{http://en.wikipedia.org/wiki/SWIG}{SWIG's wiki page}, \href{http://www.swig.org/exec.html}{SWIG's homepage}.}. 

More specifically, here is the flow of a typical simulation:
\begin{itemize}
\item Users inputs data in a python file;
\item PINSPEC python source codes process input data, perform Doppler Broadening of the cross sections if requested;
\item SWIG registers the data in C++ classes;
\item C++ contains the actualy Monte Carlo kernel, and neutrons are simulated here;
\item If any plotting is requested, generated results would be passed from C++ back to python using SWIG again and python would generate plots. 
\end{itemize}
\begin{figure}[h]
  \centering
  \includegraphics[width=5in]{images/high-level.png}
  \caption{Python Interfacing C++ Through SWIG} \label{high-level}
\end{figure}


\clearpage
\subsection{Major C++ Classes and Structures}
C++ using the following major classes and structures: 
\begin{enumerate}
\item Geometry: the umbrella object that knows the \# neutrons per batch, \# batches, \# threads, the type of geometry etc. Geometry contains region, which contains material, which contains isotopes. There are three types of geometries:
  \begin{itemize}
  \item \hi{Infinite homogeneous model}: that is, the entire geometry is one homogenized material. 
  \item \hi{Heterogeneous equivalent model}: that is, the region declared as Equivalent Fuel would be homogenized into one fuel region, and the region declared as Equivalent Moderator would be homogenized into one moderator region, and we use collision probability method to estimate the probability of neutrons traveling from one region to another. In this model neutrons only know whether they are in Equivalent Fuel or Equivalent Moderator and do not have an explicit $(x,y,z)$. 
  \item \hi{Full heterogeneous model}: this is the model where neutrons truly know their $(x,y,z)$ locations. In this model, region objects contain surfaces.
  \end{itemize}
  
\item Region: a region object knows its region name, the material inside, its region type, volume and buckling. More specifically, we support 6 region types: 
  \begin{itemize}
    \item \hi{Infinite medium}: this region covers an infinite space. 
    \item \hi{Equivalent fuel}: this region is a fuel region using the infinite equivalence model. 
    \item \hi{Equivalent moderator}: this region is a moderator region using the infinite equivalence model. 
    \item \hi{Bounded fuel}: this region is a fuel region using the true heterogeneous model. 
    \item \hi{Bounded moderator}: this region is a moderator region using the true heterogeneous model. 
    \item \hi{Bounded general}: this region is a generalized region bounded by surfaces and is used in the true heterogeneous model. 
  \end{itemize}
  %See Fig.~\ref{classRegion} for an illustration of the inheritance structure of the Region class. 
  \begin{figure}[h]
    \hspace{-1in}
    \includegraphics[width=1.5\textwidth]{images/classRegion.png}
    \caption{Inheritance Diagram of Region Class} \label{classRegion}
  \end{figure}



\item Surface: Surface objects are used to bound regions in the true heterogeneous model. A surface object knows its name, ID \#, its surface type (three sub-classes: x-plane, y-plane, z-cylinder), and its boundary condition (reflective, vacuum, interface). 
  \begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{images/classSurface.png}
    \caption{Inheritance Diagram of Surface Class}
  \end{figure}


\item Material: an material object contains one or more isotope objects, and an material object is used to filled a region object. A material object knows basic info like its name, ID \#, material density; when adding an isotope into a material, the material object needs to know the relative atomic mass associated with each isotope. 
  \begin{itemize}
  \item Note: each material and isotope isotope object needs to keep track of its number densities. Instead of having users to manually put in number densities, PINSPEC keeps track of them; notice that every time a new isotope is added, the number density of the material as well as other isotopes need to be updated as well. PINSPEC handles it by keeping a map of the isotopes with its corresponding relative atomic mass in each material object. So every time a new isotope is added, the material object loops through all existing isotopes and update the number density of the material and of each isotope. 
  \end{itemize}

\item Isotope: an isotope object can be considered as one of the most basic object in PINSPEC. We use isotope to build material, which in turn builds region, which builds geometry. An isotope object needs to have a name and atomic number, and PINSPEC would assign each isotope a unique identifier, calculate its $\displaystyle \alpha = \left(\frac{A-1}{A+1}\right)^2$, $\eta, \rho$ for SLBW, averaged cosine of scattering angle $\displaystyle \bar{\mu} = \frac{2}{3A}$ etc. 
  \begin{itemize}
    \item We asks the user to provide isotope name in the format of: isotope's periodic table name (first letter capitalized), followed by its atomic number, with a hyphen in-between.
  \end{itemize}

\item Neutron: a neutron structure knows its batch number (for running multiple batches and performing batch statistics), its previous energy (in eV) and its current energy (in eV), the region it is in, the material it is in, and the isotope it is in. For heterogeneous geometries, neutrons also know its $(x,y,z)$ location, $(u,v,w)$ velocity directions, and the closest surface. This neutron structure is being passed from class to class, and it contains the most essentially information that the other classes would depend on to perform the simulation and generate the corresponding statistics. 

\item Tally: PINSPEC uses a Tally class to keep the implementation of tally accumulation general. See Fig.~\ref{classTally} for the different sub-classes supported in the Tally class. There are also a TallyBank class that stores all the tallies, and a TallyFactory class that creates tallies. For more details, see Section~\ref{example-add-tally} for an example on how to implement a new tally type. 
  \begin{Figure}
    \vspace{-1in}
    \hspace{-1.45in}
    \includegraphics[width=2.\textwidth]{images/classTally.png}
    \caption{Inheritance Diagram of Tally Class} \label{classTally}
  \end{Figure}
\end{enumerate}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% INSTALL %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\section{Installation and How To Run} \label{install}
An overview of the installation procedures can be found on the users' guide at \href{https://github.com/mit-crpg/PINSPEC/wiki/Installing-PINSPEC}{PINSPEC's wiki page}. 

Table.~\ref{install-table} lists PINSPEC's package requirements and the third column provides installation suggestion for ubuntu users. 
\begin{table}[h]
  \centering
  \begin{tabular}{|c|c|c|} \hline
    Package & Version \# & Installation \\ \hline \hline
    Python & 2.7 & sudo apt-get install python2.7 \\ \hline
    matplotlib & 1.2 or later & sudo apt-get install python-matplotlib \\ \hline
    numpy & 1.6 or later & sudo apt-get install python-numpy \\ \hline
    scipy & 0.9 or later & sudo apt-get install python-scipy \\ \hline
    SWIG & -- &  sudo apt-get install swig \\ \hline
    GIT & -- & sudo apt-get install git \\ \hline
  \end{tabular} 
  \caption{PINSPEC Package Requirements and Installation Notes} \label{install-table}
\end{table}
Notes:
\begin{itemize}
\item Ubuntu users: 
\begin{itemize}
\item If you have Ubuntu v12.10, the default installation (aka using the commands listed in Table~\ref{install-table}) would get you the right versions. 
\item If you have an earlier version of Ubuntu, and the packages you obtained through your Ubuntu release are earlier versions than the ones listed in Table.~\ref{install-table}, we suggest you first install all the packages required, and try running PINSPEC, and python's error message would help you determine whether you need any newer version of software. 
\item If you tried the previous bullet point and decided you have to build some of these packages from source, here are examples for pulling numpy and scipy from their git repositories: 
\begin{verbatim}
> git clone git://github.com/numpy/numpy.git numpy 
> git clone git://github.com/scipy/scipy.git scipy
\end{verbatim}
Then build using python's utilities:
\begin{verbatim}
> python setup.py install
\end{verbatim}
For more details, see \href{http://scipy.org/Installing_SciPy/BuildingGeneral}{Scipy's installation page} for instance. 
\end{itemize}

\item Other Linux users: use your corresponding package management system. For instance, in Gentoo you would use `emerge' to get the above packages. 

\item Mac users: try install the listed packages using MacPort, and MacPort seems to be the Mac version of package management system, and it should make keeping track of dependencies and updating packages in the future easier. 
\end{itemize}


\clearpage
\subsection{A Special Note About Python Version}
\begin{itemize}
\item Python2 vs. Python3: because of the syntax incompatibility between python2 and python3, PINSPEC only supports python2 (more specifically it is tested mostly with python2.7). Developers could choose to update the python source codes into python3 syntax in the future if python3 gets more popular; though for now the easiest thing to do for users with python3 would be to install a copy of python2.7 as well, and every command that has `python' in it, using the syntax `python2.7' would request the correct version of python. 

\item Mac users may run into problems with running our python setup.py file (located in the main directory). It is recommended to use the env prefix as in the following example for users with gcc-4.7:
\begin{verbatim}
env CC=gcc-mp-4.7 python setup.py install --user
\end{verbatim}
\end{itemize}

\clearpage
\subsection{Additional Tools}
This section contains some notes on useful tools that might help developers. 
\begin{enumerate}
\item GIT. 

\item SCP

\item SSHFS: 
\begin{itemize}

\item To see what sftp subsystems are mounted: 
\begin{verbatim}
    ps aux | grep -i sftp | grep -v grep
\end{verbatim}


\end{itemize}

\end{enumerate}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PYTHON %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\section{Manipulating Python Inputs}\label{python}
\subsection{Utilizing Tally Arithmetic}
There are three tally arithmetics supported in PINSPEC: 
\begin{enumerate}
\item tally1 + tally2: creates a new tally with the correct statistics. 
\item tally1 + 3.5:
\item tally1.addFloats(numpy.array([1,2])), or addIntegers, or addDoubles. 
\end{enumerate}


\clearpage
\subsection{Example: Add A New Isotope}

\clearpage
\subsection{Example: Add A New Cross Section}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% C++ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\section{Manipulating C++ Codes}\label{C++}
\subsection{Create A New Source File}
If you create a new source file, make sure you add it to \textit{setup.py}

\begin{itemize}
\item If you need to pass data from the python input file into the C file, or you would like to retrieve the results generated by C++ and plot or print it using python, see Section~\ref{data}. 
\item Make sure you update the doxygen commenting accordingly, and run doxygen by:
\begin{verbatim}
 doxygen docs/Doxyfile
\end{verbatim}
See more details in Section.~\ref{doxygen}. 

\item If you add in any additional functions, it is nice to update the test suites accordingly. 

\item Two examples are shown about how to add a new tally and a new surface. 
\end{itemize}

\subsection{Passing Data Between Python and C++} \label{data}
If you would like to gain access to an array of data, you need to do so through SWIG. Examples can be found in Geometry.i which contains numpy template. 


\subsection{Doxygen Commenting} \label{doxygen}
To generate html and pdf from source code commenting, run Doxygen by the following command:
\begin{verbatim}
 doxygen docs/doxygen/Doxyfile
\end{verbatim}

If you modify the source code, please update the Doxygen commenting accordingly. For instance, here are some styling suggestions:
\begin{enumerate}
\item For any class structure (including super-class and sub-class), use @class followed by class name, header file name, and header file path. Examples:
\begin{verbatim}
@class Surface Surface.h "pinspec/src/Surface.h"
@class XPlane Surface.h "pinspec/src/Surface.h"
@class YPlane Surface.h "pinspec/src/Surface.h"
\end{verbatim}
In the above examples, Surface is the super-class, and XPlane and YPlane are sub-classes. 

\item For any structure, try using @brief followed by a one-line short description, as well as @details followed by a longer description if needed. 

\item For any structure, use @param followed by parameter name and description to comment on the inputs of a method, and use @return followed by variable name and description to comment on the outputs of a method. 
\end{enumerate}


\clearpage
\subsection{Update Test Suites}

\clearpage
\subsection{Example: Implement A New Surface}

\clearpage
\subsection{Example: Implement A New Tally} \label{example-add-tally}


\clearpage
\subsection{Example: Implement A Monte Carlo Variance Reduction Technique}
The main kernel that performs the Monte Carlo simulation is contained in Geometry.cpp as runMonteCarloSimulation(). 

\begin{algorithm}

\caption{High Level Monte Carlo Kernel}
\begin{algorithmic}
\FOR{each batch}
\FOR{each neutron inside the batch}
\STATE Initialize neutrons:

\ENDFOR
\ENDFOR
\end{algorithmic}
\end{algorithm}

\end{document}
